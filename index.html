<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snapchat Media Merger</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        .drag-over {
            border-color: rgb(59, 130, 246) !important;
            background-color: rgb(239, 246, 255) !important;
            transform: scale(1.02);
            transition: all 0.2s ease;
        }
        
        .processing {
            animation: pulse 2s infinite;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        
        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .slide-down {
            animation: slideDown 0.3s ease-out;
        }
        
        .loading-spinner {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .status-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            font-size: 0.875rem;
        }
        
        .status-processing {
            background-color: rgb(249, 250, 251);
            border: 2px solid rgb(209, 213, 219);
        }
        
        .status-success {
            background-color: rgb(220, 252, 231);
            color: rgb(34, 197, 94);
        }
        
        .status-error {
            background-color: rgb(254, 226, 226);
            color: rgb(239, 68, 68);
        }
        
        .compact-drop-zone {
            padding: 1.5rem !important;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Header -->
    <header class="bg-white shadow-sm border-b">
        <div class="max-w-7xl mx-auto px-4 py-6">
            <div class="text-center">
                <h1 class="text-3xl font-bold text-gray-900 mb-2">Snapchat Media Merger</h1>
                <p class="text-gray-600">Merge your exported Snapchat photos and videos with their overlay filters</p>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="max-w-7xl mx-auto px-4 py-8">
        <!-- Instructions Accordion -->
        <div id="helpAccordion" class="mb-6">
            <button id="helpToggle" class="flex items-center text-sm text-gray-600 hover:text-gray-800 transition-colors">
                <span class="w-5 h-5 mr-2 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center text-xs font-semibold">?</span>
                <span>How it works</span>
                <svg id="helpChevron" class="w-4 h-4 ml-2 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
            <div id="helpContent" class="hidden mt-4 bg-blue-50 border border-blue-200 rounded-lg p-6">
                <div class="grid md:grid-cols-2 gap-4 text-sm text-blue-800">
                    <div>
                        <h3 class="font-medium mb-2">1. File Naming Convention</h3>
                        <ul class="space-y-1 ml-4">
                            <li>‚Ä¢ <code class="bg-blue-100 px-2 py-1 rounded">[id]-main.jpg</code> - Base image</li>
                            <li>‚Ä¢ <code class="bg-blue-100 px-2 py-1 rounded">[id]-main.mp4</code> - Base video</li>
                            <li>‚Ä¢ <code class="bg-blue-100 px-2 py-1 rounded">[id]-overlay.png</code> - Filter overlay</li>
                        </ul>
                    </div>
                    <div>
                        <h3 class="font-medium mb-2">2. Drag & Drop</h3>
                        <p>Drop multiple files at once. The app will automatically pair and merge them based on matching IDs.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Drop Zone -->
        <div id="dropZone" class="border-2 border-dashed border-gray-300 rounded-lg p-12 text-center mb-8 transition-all duration-300 hover:border-gray-400 hover:bg-gray-50">
            <div id="dropZoneContent" class="space-y-4">
                <div class="text-6xl text-gray-400">üìÅ</div>
                <div>
                    <p class="text-xl font-medium text-gray-700">Drop your Snapchat export files here</p>
                    <p class="text-gray-500 mt-2">Or click to select files</p>
                </div>
                <input type="file" id="fileInput" multiple accept="image/*,video/*" class="hidden">
                <button id="selectFilesBtn" class="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium">
                    Select Files
                </button>
            </div>
            <!-- Compact version shown after files are added -->
            <div id="dropZoneCompact" class="hidden space-y-2">
                <div class="text-2xl text-gray-400">üìÅ</div>
                <div>
                    <p class="text-sm font-medium text-gray-600">Drop more files or</p>
                    <button id="selectMoreBtn" class="text-blue-600 hover:text-blue-700 text-sm font-medium underline">
                        select additional files
                    </button>
                </div>
            </div>
        </div>

        <!-- Unified Files List -->
        <div id="filesSection" class="hidden">
            <div class="bg-white rounded-lg shadow-sm border border-gray-200">
                <!-- Header with actions -->
                <div class="flex items-center justify-between p-6 border-b border-gray-200">
                    <h3 class="text-xl font-semibold text-gray-900">Your Files</h3>
                    <div class="flex items-center space-x-3">
                        <button id="clearAllBtn" class="text-gray-600 hover:text-gray-800 px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors text-sm font-medium">
                            Clear All
                        </button>
                        <button id="downloadAllBtn" class="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed text-sm font-medium" disabled>
                            üì¶ Download ZIP
                        </button>
                    </div>
                </div>
                
                <!-- Files list -->
                <div id="filesList" class="divide-y divide-gray-200">
                    <!-- File items will be inserted here -->
                </div>
            </div>
        </div>
    </main>

    <script>
        class SnapchatMediaMerger {
            constructor() {
                this.files = [];
                this.processedFiles = [];
                this.fileItems = new Map(); // Track file items by ID
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                const dropZone = document.getElementById('dropZone');
                const fileInput = document.getElementById('fileInput');
                const selectFilesBtn = document.getElementById('selectFilesBtn');
                const selectMoreBtn = document.getElementById('selectMoreBtn');
                const downloadAllBtn = document.getElementById('downloadAllBtn');
                const clearAllBtn = document.getElementById('clearAllBtn');
                const helpToggle = document.getElementById('helpToggle');

                // Drag and drop events
                dropZone.addEventListener('dragover', this.handleDragOver.bind(this));
                dropZone.addEventListener('dragleave', this.handleDragLeave.bind(this));
                dropZone.addEventListener('drop', this.handleDrop.bind(this));

                // File input events
                selectFilesBtn.addEventListener('click', () => fileInput.click());
                selectMoreBtn.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));

                // Control buttons
                downloadAllBtn.addEventListener('click', this.downloadAllAsZip.bind(this));
                clearAllBtn.addEventListener('click', this.clearAll.bind(this));

                // Help accordion
                helpToggle.addEventListener('click', this.toggleHelp.bind(this));

                // Global drag and drop handlers to prevent browser default behavior
                this.setupGlobalDragHandlers();
            }

            setupGlobalDragHandlers() {
                // Prevent default drag behaviors on the entire document
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    document.addEventListener(eventName, this.preventDefaults.bind(this), false);
                });

                // Highlight drop zone when item is dragged over page
                ['dragenter', 'dragover'].forEach(eventName => {
                    document.addEventListener(eventName, this.highlight.bind(this), false);
                });

                // Unhighlight drop zone when item leaves or is dropped
                ['dragleave', 'drop'].forEach(eventName => {
                    document.addEventListener(eventName, this.unhighlight.bind(this), false);
                });
            }

            preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            highlight(e) {
                const dropZone = document.getElementById('dropZone');
                if (dropZone && !dropZone.classList.contains('drag-over')) {
                    dropZone.classList.add('border-blue-300', 'bg-blue-25');
                }
            }

            unhighlight(e) {
                // Only unhighlight if we're not over the drop zone
                const dropZone = document.getElementById('dropZone');
                if (dropZone && !dropZone.contains(e.target) && !dropZone.contains(e.relatedTarget)) {
                    dropZone.classList.remove('border-blue-300', 'bg-blue-25');
                }
            }

            handleDragOver(e) {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'copy';
                e.currentTarget.classList.add('drag-over');
            }

            handleDragLeave(e) {
                e.preventDefault();
                e.stopPropagation();
                
                // Only remove drag styling if actually leaving the drop zone
                if (!e.currentTarget.contains(e.relatedTarget)) {
                    e.currentTarget.classList.remove('drag-over');
                }
            }

            handleDrop(e) {
                e.preventDefault();
                e.stopPropagation();
                e.currentTarget.classList.remove('drag-over');

                const files = Array.from(e.dataTransfer.files);
                if (files.length > 0) {
                    this.processFiles(files);
                }
            }

            handleFileSelect(e) {
                const files = Array.from(e.target.files);
                this.processFiles(files);
            }

            toggleHelp() {
                const helpContent = document.getElementById('helpContent');
                const helpChevron = document.getElementById('helpChevron');
                
                if (helpContent.classList.contains('hidden')) {
                    helpContent.classList.remove('hidden');
                    helpContent.classList.add('slide-down');
                    helpChevron.style.transform = 'rotate(180deg)';
                } else {
                    helpContent.classList.add('hidden');
                    helpContent.classList.remove('slide-down');
                    helpChevron.style.transform = 'rotate(0deg)';
                }
            }

            clearAll() {
                // Clear all data
                this.files = [];
                this.processedFiles = [];
                this.fileItems.clear();
                
                // Reset UI
                const filesList = document.getElementById('filesList');
                filesList.innerHTML = '';
                
                const filesSection = document.getElementById('filesSection');
                filesSection.classList.add('hidden');
                
                // Reset drop zone to full size
                this.resetDropZone();
                
                // Disable download button
                document.getElementById('downloadAllBtn').disabled = true;
            }

            resetDropZone() {
                const dropZoneContent = document.getElementById('dropZoneContent');
                const dropZoneCompact = document.getElementById('dropZoneCompact');
                const dropZone = document.getElementById('dropZone');
                
                dropZoneContent.classList.remove('hidden');
                dropZoneCompact.classList.add('hidden');
                dropZone.classList.remove('compact-drop-zone');
            }

            switchToCompactDropZone() {
                const dropZoneContent = document.getElementById('dropZoneContent');
                const dropZoneCompact = document.getElementById('dropZoneCompact');
                const dropZone = document.getElementById('dropZone');
                
                dropZoneContent.classList.add('hidden');
                dropZoneCompact.classList.remove('hidden');
                dropZone.classList.add('compact-drop-zone');
            }

            async processFiles(files) {
                // Add new files to existing array instead of replacing
                const newFiles = Array.from(files);
                this.files = [...this.files, ...newFiles];
                
                // Show files section and switch to compact drop zone
                document.getElementById('filesSection').classList.remove('hidden');
                this.switchToCompactDropZone();

                // Group only the new files by ID and type
                const fileGroups = this.groupFiles(newFiles);
                
                // Add file items to the list immediately
                for (const [id, group] of Object.entries(fileGroups)) {
                    this.addFileItem(id, group);
                }
                
                // Process each group
                for (const [id, group] of Object.entries(fileGroups)) {
                    try {
                        await this.processFileGroup(id, group);
                    } catch (error) {
                        console.error(`Error processing group ${id}:`, error);
                        this.updateFileItem(id, 'error', 'Error processing files - please check file format');
                    }
                }

                // Update download button state
                this.updateDownloadButtonState();
            }

            groupFiles(files) {
                const groups = {};

                files.forEach(file => {
                    const match = file.name.match(/^(.+?)-(main|overlay)\.(jpg|jpeg|png|mp4)$/i);
                    if (match) {
                        const [, id, type, ext] = match;
                        if (!groups[id]) {
                            groups[id] = {};
                        }
                        groups[id][type.toLowerCase()] = file;
                    } else {
                        // Handle files that don't match the pattern
                        const timestamp = Date.now();
                        const fallbackId = `unknown_${timestamp}_${Math.random().toString(36).substr(2, 9)}`;
                        groups[fallbackId] = { main: file };
                    }
                });

                return groups;
            }

            addFileItem(id, group) {
                const { main, overlay } = group;
                const filesList = document.getElementById('filesList');
                
                const fileItem = document.createElement('div');
                fileItem.id = `file-${id}`;
                fileItem.className = 'p-4 fade-in';
                
                const isVideo = main && main.type.startsWith('video/');
                const fileType = isVideo ? 'Video' : 'Image';
                
                fileItem.innerHTML = `
                    <div class="flex items-center space-x-4">
                        <!-- Status Icon -->
                        <div class="status-icon status-processing">
                            <div class="loading-spinner w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full"></div>
                        </div>
                        
                        <!-- File Info -->
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center space-x-3">
                                <h4 class="text-sm font-semibold text-gray-900 truncate">${id}</h4>
                                <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-gray-100 text-gray-600">
                                    ${fileType}
                                </span>
                                ${overlay ? '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-600">Has Overlay</span>' : ''}
                            </div>
                            <p class="text-sm text-gray-500 mt-1">Processing...</p>
                            <p class="text-xs text-gray-400 truncate">Original: ${main ? main.name : 'Unknown'}</p>
                        </div>
                        
                        <!-- Preview/Actions Area -->
                        <div class="w-16 h-16 bg-gray-100 rounded-lg flex items-center justify-center">
                            <div class="text-2xl text-gray-400">${isVideo ? 'üé¨' : 'üñºÔ∏è'}</div>
                        </div>
                    </div>
                `;
                
                filesList.appendChild(fileItem);
                this.fileItems.set(id, { element: fileItem, status: 'processing', group });
            }

            updateFileItem(id, status, message, processedFile = null) {
                const item = this.fileItems.get(id);
                if (!item) return;
                
                const element = item.element;
                const group = item.group;
                const { main, overlay } = group;
                const isVideo = main && main.type.startsWith('video/');
                const fileType = isVideo ? 'Video' : 'Image';
                
                let statusIconHTML = '';
                let previewHTML = '';
                let actionsHTML = '';
                
                switch (status) {
                    case 'processing':
                        statusIconHTML = `
                            <div class="status-icon status-processing">
                                <div class="loading-spinner w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full"></div>
                            </div>
                        `;
                        previewHTML = `
                            <div class="w-16 h-16 bg-gray-100 rounded-lg flex items-center justify-center">
                                <div class="text-2xl text-gray-400">${isVideo ? 'üé¨' : 'üñºÔ∏è'}</div>
                            </div>
                        `;
                        break;
                    case 'success':
                        statusIconHTML = `
                            <div class="status-icon status-success">
                                ‚úì
                            </div>
                        `;
                        if (processedFile) {
                            const previewUrl = URL.createObjectURL(processedFile.blob);
                            // Use the actual blob type for preview
                            const previewType = processedFile.blob.type;
                            previewHTML = isVideo 
                                ? `<video class="w-16 h-16 object-cover rounded-lg" muted>
                                     <source src="${previewUrl}" type="${previewType}">
                                   </video>`
                                : `<img src="${previewUrl}" alt="${id}" class="w-16 h-16 object-cover rounded-lg">`;
                            
                            actionsHTML = `
                                <button onclick="downloadFile('${id}')" 
                                        class="ml-3 bg-blue-600 text-white px-3 py-1 rounded-md hover:bg-blue-700 transition-colors text-xs font-medium">
                                    Download
                                </button>
                            `;
                        }
                        break;
                    case 'error':
                        statusIconHTML = `
                            <div class="status-icon status-error">
                                ‚úï
                            </div>
                        `;
                        previewHTML = `
                            <div class="w-16 h-16 bg-red-100 rounded-lg flex items-center justify-center">
                                <div class="text-2xl text-red-400">‚ö†Ô∏è</div>
                            </div>
                        `;
                        break;
                }
                
                element.innerHTML = `
                    <div class="flex items-center space-x-4">
                        <!-- Status Icon -->
                        ${statusIconHTML}
                        
                        <!-- File Info -->
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center space-x-3">
                                <h4 class="text-sm font-semibold text-gray-900 truncate">${id}</h4>
                                <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-gray-100 text-gray-600">
                                    ${fileType}
                                </span>
                                ${overlay ? '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-600">Has Overlay</span>' : ''}
                            </div>
                            <p class="text-sm ${status === 'error' ? 'text-red-600' : 'text-gray-500'} mt-1">${message}</p>
                            <p class="text-xs text-gray-400 truncate">Original: ${main ? main.name : 'Unknown'}</p>
                        </div>
                        
                        <!-- Preview/Actions Area -->
                        <div class="flex items-center">
                            ${previewHTML}
                            ${actionsHTML}
                        </div>
                    </div>
                `;
                
                item.status = status;
                if (processedFile) {
                    item.processedFile = processedFile;
                }
            }

            updateDownloadButtonState() {
                const hasProcessedFiles = this.processedFiles.length > 0;
                document.getElementById('downloadAllBtn').disabled = !hasProcessedFiles;
            }

            async processFileGroup(id, group) {
                const { main, overlay } = group;

                if (!main) {
                    this.updateFileItem(id, 'error', 'No main file found');
                    return;
                }

                const isVideo = main.type.startsWith('video/');

                if (isVideo) {
                    this.updateFileItem(id, 'processing', 'Processing video (attempting MP4 format)...');
                    await this.processVideo(id, main, overlay);
                } else {
                    this.updateFileItem(id, 'processing', 'Processing image...');
                    await this.processImage(id, main, overlay);
                }
            }

            async processImage(id, mainFile, overlayFile) {
                return new Promise((resolve, reject) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    let imagesLoaded = 0;
                    const totalImages = overlayFile ? 2 : 1;

                    const mainImg = new Image();
                    const overlayImg = overlayFile ? new Image() : null;

                    const checkComplete = () => {
                        imagesLoaded++;
                        if (imagesLoaded === totalImages) {
                            // Set canvas size to main image dimensions
                            canvas.width = mainImg.width;
                            canvas.height = mainImg.height;

                            // Draw main image
                            ctx.drawImage(mainImg, 0, 0);

                            // Draw overlay if present
                            if (overlayImg) {
                                ctx.drawImage(overlayImg, 0, 0, canvas.width, canvas.height);
                            }

                            // Convert to blob
                            canvas.toBlob((blob) => {
                                const processedFile = {
                                    id,
                                    type: 'image',
                                    blob,
                                    filename: `${id}-merged.jpg`,
                                    originalMain: mainFile.name,
                                    hasOverlay: !!overlayFile
                                };

                                this.processedFiles.push(processedFile);
                                this.updateFileItem(id, 'success', 'Image processed successfully', processedFile);
                                this.updateDownloadButtonState();
                                resolve();
                            }, 'image/jpeg', 0.9);
                        }
                    };

                    mainImg.onload = checkComplete;
                    mainImg.onerror = () => reject(new Error('Failed to load main image'));

                    if (overlayImg) {
                        overlayImg.onload = checkComplete;
                        overlayImg.onerror = () => reject(new Error('Failed to load overlay image'));
                        overlayImg.src = URL.createObjectURL(overlayFile);
                    }

                    mainImg.src = URL.createObjectURL(mainFile);
                });
            }

            async processVideo(id, mainFile, overlayFile) {
                return new Promise((resolve, reject) => {
                    const video = document.createElement('video');
                    video.muted = true; // Mute playback during processing - no sound
                    video.crossOrigin = 'anonymous'; // Enable audio capture
                    video.preload = 'metadata'; // Ensure metadata is loaded
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    let overlayImg = null;
                    let mediaRecorder;
                    let recordedChunks = [];
                    let onTimeUpdate, onCanPlayThrough, onSeeked; // Event listener references for cleanup

                    const processFrame = () => {
                        if (video.paused || video.ended) {
                            return;
                        }

                        // More lenient processing - start as soon as we have current data
                        if (video.readyState >= 2) { // HAVE_CURRENT_DATA is sufficient
                            // Clear canvas with transparent background for cleaner output
                            ctx.clearRect(0, 0, canvas.width, canvas.height);

                            // Draw video frame preserving aspect ratio
                            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                            // Draw overlay if present
                            if (overlayImg) {
                                ctx.drawImage(overlayImg, 0, 0, canvas.width, canvas.height);
                            }
                        }

                        requestAnimationFrame(processFrame);
                    };

                    video.addEventListener('loadedmetadata', () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        
                        console.log('Video metadata loaded:', {
                            duration: video.duration,
                            width: video.videoWidth,
                            height: video.videoHeight,
                            hasAudio: video.mozHasAudio || video.webkitAudioDecodedByteCount > 0 || Boolean(video.audioTracks && video.audioTracks.length)
                        });

                        // Set up MediaRecorder with fallback for MIME type support
                        const canvasStream = canvas.captureStream(30); // 30 FPS
                        
                        // Create a combined stream with video from canvas and audio from original video
                        const stream = new MediaStream();
                        
                        // Add video track from canvas
                        canvasStream.getVideoTracks().forEach(track => {
                            stream.addTrack(track);
                        });
                        
                        // Add audio track from original video using captureStream (more reliable)
                        let audioContext, audioSource, audioDestination;
                        try {
                            // First try the simpler captureStream method which is more reliable
                            console.log('Attempting to capture video stream with audio...');
                            const videoStream = video.captureStream ? video.captureStream() : video.mozCaptureStream();
                            const audioTracks = videoStream.getAudioTracks();
                            
                            if (audioTracks.length > 0) {
                                console.log(`Found ${audioTracks.length} audio track(s) in video stream`);
                                audioTracks.forEach(track => {
                                    console.log('Adding audio track:', track.label, track.enabled, track.readyState);
                                    stream.addTrack(track);
                                });
                            } else {
                                console.warn('No audio tracks found in video stream, trying Web Audio API fallback');
                                throw new Error('No audio tracks in captureStream');
                            }
                        } catch (error) {
                            console.warn('captureStream failed, trying Web Audio API:', error);
                            // Fallback to Web Audio API method
                            try {
                                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                                    sampleRate: 44100
                                });
                                
                                // Resume audio context if suspended
                                if (audioContext.state === 'suspended') {
                                    audioContext.resume().catch(err => {
                                        console.warn('Failed to resume audio context:', err);
                                    });
                                }
                                
                                audioSource = audioContext.createMediaElementSource(video);
                                audioDestination = audioContext.createMediaStreamDestination();
                                
                                // Important: Create a gain node to maintain audio connection
                                const gainNode = audioContext.createGain();
                                gainNode.gain.value = 1.0; // Keep original volume for recording
                                
                                // Connect: source -> gain -> destination
                                audioSource.connect(gainNode);
                                gainNode.connect(audioDestination);
                                
                                // Add the audio tracks to our stream
                                audioDestination.stream.getAudioTracks().forEach(track => {
                                    stream.addTrack(track);
                                });
                                
                                console.log('Web Audio API setup successful');
                            } catch (webAudioError) {
                                console.error('Both audio capture methods failed:', webAudioError);
                                console.warn('Proceeding without audio');
                            }
                        }
                        
                        // Try MP4 first for QuickTime compatibility, fallback to WebM if needed
                        const mimeTypes = [
                            'video/mp4;codecs="avc1.42E01E,mp4a.40.2"', // H.264 Baseline + AAC
                            'video/mp4;codecs="avc1.4D401E,mp4a.40.2"', // H.264 Main + AAC
                            'video/mp4;codecs=h264,aac',
                            'video/mp4;codecs=avc1,mp4a',
                            'video/mp4',
                            'video/webm;codecs=vp9,opus', // Fallback to WebM if MP4 not supported
                            'video/webm;codecs=vp8,opus',
                            'video/webm'
                        ];
                        
                        let selectedMimeType = 'video/mp4'; // prefer MP4
                        let isMP4Recording = false;
                        
                        for (const mimeType of mimeTypes) {
                            if (MediaRecorder.isTypeSupported(mimeType)) {
                                selectedMimeType = mimeType;
                                isMP4Recording = mimeType.includes('mp4');
                                console.log('Selected MIME type for recording:', mimeType, isMP4Recording ? '(True MP4)' : '(WebM fallback)');
                                break;
                            }
                        }
                        
                        // Configure MediaRecorder with audio-friendly settings
                        const mediaRecorderOptions = {
                            mimeType: selectedMimeType,
                        };
                        
                        // Add bitrate settings optimized for the recording format
                        if (isMP4Recording) {
                            // MP4 settings for QuickTime compatibility
                            mediaRecorderOptions.audioBitsPerSecond = 128000; // 128kbps AAC
                            mediaRecorderOptions.videoBitsPerSecond = 2000000; // 2Mbps H.264
                        } else {
                            // WebM fallback settings
                            mediaRecorderOptions.audioBitsPerSecond = 128000; // 128kbps Opus
                            mediaRecorderOptions.videoBitsPerSecond = 2500000; // 2.5Mbps VP8/VP9
                        }
                        
                        console.log('Creating MediaRecorder with options:', mediaRecorderOptions);
                        console.log('Stream tracks:', stream.getTracks().map(t => ({ kind: t.kind, enabled: t.enabled, readyState: t.readyState })));
                        
                        mediaRecorder = new MediaRecorder(stream, mediaRecorderOptions);

                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                recordedChunks.push(event.data);
                            }
                        };

                        mediaRecorder.onstop = () => {
                            // Clean up audio context if we used Web Audio API
                            try {
                                if (audioContext) {
                                    if (audioSource) audioSource.disconnect();
                                    if (audioDestination) audioDestination.disconnect();
                                    audioContext.close();
                                }
                            } catch (cleanupError) {
                                console.warn('Audio context cleanup failed:', cleanupError);
                            }
                            
                            // Handle the recorded format appropriately
                            console.log('Recording completed, creating blob with type:', selectedMimeType);
                            console.log('Total chunks:', recordedChunks.length);
                            
                            // Create blob with the actual recorded format
                            const blob = new Blob(recordedChunks, { type: selectedMimeType });
                            
                            // Set file extension based on actual format for compatibility
                            const fileExtension = isMP4Recording ? 'mp4' : 'webm';
                            const formatMessage = isMP4Recording ? 
                                'MP4 video processed (QuickTime compatible)' : 
                                'WebM video processed (Chrome/Firefox compatible)';
                            
                            console.log('Created blob:', {
                                size: blob.size,
                                type: blob.type,
                                filename: `${id}-merged.${fileExtension}`,
                                isMP4Recording
                            });
                            const processedFile = {
                                id,
                                type: 'video',
                                blob,
                                filename: `${id}-merged.${fileExtension}`,
                                originalMain: mainFile.name,
                                hasOverlay: !!overlayFile
                            };

                            this.processedFiles.push(processedFile);
                            this.updateFileItem(id, 'success', formatMessage, processedFile);
                            this.updateDownloadButtonState();
                            resolve();
                        };

                        // Load overlay if present
                        if (overlayFile) {
                            overlayImg = new Image();
                            overlayImg.onload = () => {
                                startRecording();
                            };
                            overlayImg.src = URL.createObjectURL(overlayFile);
                        } else {
                            startRecording();
                        }

                        function startRecording() {
                            let recordingStarted = false;
                            
                            // Function to check if frame has actual content (not black/empty)
                            const hasFrameContent = () => {
                                if (video.readyState < 2) return false;
                                
                                // More lenient approach - just check if we have a stable current time
                                if (video.currentTime >= 0.05) { // 50ms threshold - very early but avoids black frames
                                    return true;
                                }
                                
                                // Fallback: quick pixel sampling for very early detection
                                try {
                                    const testCanvas = document.createElement('canvas');
                                    const testCtx = testCanvas.getContext('2d');
                                    testCanvas.width = 16; // Smaller for faster processing
                                    testCanvas.height = 16;
                                    
                                    testCtx.drawImage(video, 0, 0, 16, 16);
                                    const imageData = testCtx.getImageData(0, 0, 16, 16);
                                    const data = imageData.data;
                                    
                                    // Quick check - just sample a few pixels
                                    let nonBlackPixels = 0;
                                    for (let i = 0; i < data.length; i += 16) { // Sample every 4th pixel
                                        const r = data[i], g = data[i + 1], b = data[i + 2];
                                        if (r > 5 || g > 5 || b > 5) { // Very low threshold for early detection
                                            nonBlackPixels++;
                                        }
                                    }
                                    
                                    return nonBlackPixels > 2; // If we find more than 2 non-black pixels
                                } catch (error) {
                                    console.warn('Error checking frame content:', error);
                                    return video.currentTime > 0.02; // Fallback: 20ms delay
                                }
                            };
                            
                            // Function to start recording once we have actual content
                            const startRecordingWithContent = () => {
                                if (recordingStarted) return;
                                
                                if (hasFrameContent()) {
                                    recordingStarted = true;
                                    console.log(`Starting recording at ${video.currentTime}s`);
                                    // Start recording without timeslicing for better audio continuity
                                    mediaRecorder.start();
                                    processFrame();
                                } else if (video.currentTime > 1) {
                                    // Fallback: start recording after 1 second even if no content detected
                                    console.warn('Starting recording after 1s timeout');
                                    recordingStarted = true;
                                    mediaRecorder.start();
                                    processFrame();
                                }
                            };
                            
                            // Listen for timeupdate to check for actual content
                            onTimeUpdate = () => {
                                if (!recordingStarted && video.currentTime > 0) {
                                    startRecordingWithContent();
                                }
                            };
                            
                            // Listen for when video can play through
                            onCanPlayThrough = () => {
                                video.removeEventListener('canplaythrough', onCanPlayThrough);
                                // Immediate check - no delay needed with our improved detection
                                if (!recordingStarted) {
                                    startRecordingWithContent();
                                }
                            };
                            
                            // Also listen for seeked event for immediate response
                            onSeeked = () => {
                                if (!recordingStarted && video.currentTime >= 0) {
                                    startRecordingWithContent();
                                }
                            };
                            
                            video.addEventListener('timeupdate', onTimeUpdate);
                            video.addEventListener('canplaythrough', onCanPlayThrough);
                            video.addEventListener('seeked', onSeeked);
                            
                            // Ensure video starts from the beginning
                            video.currentTime = 0;
                            
                            // Start the video silently for processing
                            video.play().then(() => {
                                console.log('Video started playing successfully (muted for processing)');
                                // Audio context will be managed automatically for recording
                            }).catch(error => {
                                console.error('Error playing video:', error);
                                reject(error);
                            });
                        }
                    });

                    video.addEventListener('ended', () => {
                        mediaRecorder.stop();
                        // Clean up event listeners
                        video.removeEventListener('timeupdate', onTimeUpdate);
                        video.removeEventListener('canplaythrough', onCanPlayThrough);
                        video.removeEventListener('seeked', onSeeked);
                    });

                    video.addEventListener('error', () => {
                        reject(new Error('Failed to load video'));
                    });

                    video.src = URL.createObjectURL(mainFile);
                });
            }


            async downloadAllAsZip() {
                const zip = new JSZip();

                // Add all processed files to zip in their native formats
                this.processedFiles.forEach(file => {
                    zip.file(file.filename, file.blob);
                });

                // Generate and download zip
                try {
                    const zipBlob = await zip.generateAsync({ type: 'blob' });
                    const url = URL.createObjectURL(zipBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `snapchat-merged-${Date.now()}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('Error creating ZIP:', error);
                    alert('Error creating ZIP file. Please try downloading files individually.');
                }
            }

            downloadFile(id) {
                const fileItem = this.fileItems.get(id);
                if (fileItem && fileItem.processedFile) {
                    const file = fileItem.processedFile;
                    
                    // Download the file in its native recorded format (no conversion needed)
                    const url = URL.createObjectURL(file.blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = file.filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    console.log('Downloaded file:', file.filename, 'Type:', file.blob.type);
                }
            }
        }

        // Global function for download buttons
        function downloadFile(id) {
            window.snapchatMerger.downloadFile(id);
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            window.snapchatMerger = new SnapchatMediaMerger();
        });
    </script>
</body>
</html>